import jsPDF from 'jspdf';

export interface ResumeSection {
  type: 'header' | 'section';
  title: string;
  content: string[];
}

/**
 * Professional PDF Generator - Maintains exact formatting like the original
 */
export class ProfessionalPDFGenerator {
  
  static async generatePDF(
    resumeContent: string,
    jobTitle: string,
    companyName: string
  ): Promise<Blob> {
    return new Promise((resolve, reject) => {
      try {
        console.log('🚀 Starting PDF generation...');
        console.log('📄 Content length:', resumeContent?.length || 0);
        
        if (!resumeContent || typeof resumeContent !== 'string' || resumeContent.trim().length === 0) {
          throw new Error('Resume content is empty or invalid');
        }
        
        const pdf = new jsPDF();
        
        // Clean the content first - remove any existing footer text
        const cleanContent = this.cleanResumeContent(resumeContent);
        
        // Parse into structured sections
        const sections = this.parseResumeStructure(cleanContent);
        
        console.log('📄 Generating PDF with sections:', sections.map(s => s.type + ': ' + s.title));
        
        // Generate PDF with professional formatting
        this.renderProfessionalPDF(pdf, sections, jobTitle, companyName);
        
        // Return as blob
        const pdfBlob = pdf.output('blob');
        console.log('✅ PDF generated successfully');
        resolve(pdfBlob);
      } catch (error) {
        console.error('❌ PDF Generation Error:', error);
        reject(new Error(`PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`));
      }
    });
  }

  /**
   * Clean resume content of any existing footer text
   */
  private static cleanResumeContent(content: string): string {
    if (!content || typeof content !== 'string') {
      console.warn('⚠️ Invalid content provided to PDF generator');
      return 'Resume content not available';
    }

    return content
      // Remove any existing AI-generated footer text
      .replace(/AI-Optimized Resume for.*?Generated by FLASHFIRE.*?\d{2}\/\d{2}\/\d{4}/gs, '')
      .replace(/•\s*Generated by FLASHFIRE.*$/gm, '')
      .replace(/Generated by FLASHFIRE.*$/gm, '')
      .replace(/\s*•\s*AI-Optimized.*$/gm, '')
      // Clean up extra whitespace
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      .trim();
  }

  /**
   * Parse resume into clean structure maintaining original format
   */
  private static parseResumeStructure(content: string): ResumeSection[] {
    if (!content) {
      return [{
        type: 'header',
        title: 'Header',
        content: ['Resume content not available']
      }];
    }

    const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const sections: ResumeSection[] = [];
    let currentSection: ResumeSection | null = null;
    
    for (const line of lines) {
      if (this.isSectionHeader(line)) {
        // Save previous section
        if (currentSection && currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        
        // Start new section
        currentSection = {
          type: 'section',
          title: line,
          content: []
        };
      } else if (currentSection) {
        // Add to current section
        currentSection.content.push(line);
      } else {
        // This is header content (name, contact info)
        if (sections.length === 0 || sections[0].type !== 'header') {
          sections.unshift({
            type: 'header',
            title: 'Header',
            content: [line]
          });
        } else {
          sections[0].content.push(line);
        }
      }
    }
    
    // Add final section
    if (currentSection && currentSection.content.length > 0) {
      sections.push(currentSection);
    }

    // Ensure we have at least a header section
    if (sections.length === 0) {
      sections.push({
        type: 'header',
        title: 'Header',
        content: ['Professional Resume']
      });
    }
    
    return sections;
  }

  /**
   * Check if line is a section header
   */
  private static isSectionHeader(line: string): boolean {
    if (!line || typeof line !== 'string') return false;

    const sectionKeywords = [
      'education', 'technical skills', 'experience', 'projects', 'certifications',
      'summary', 'professional summary', 'objective', 'profile',
      'work experience', 'professional experience', 'employment',
      'academic background', 'qualifications', 'skills', 'core competencies',
      'expertise', 'achievements', 'awards', 'leadership',
      'additional technologies', 'additional relevant skills', 'additional technical skills'
    ];
    
    const lowerLine = line.toLowerCase().trim();
    
    return sectionKeywords.some(keyword => 
      lowerLine === keyword || 
      (lowerLine.includes(keyword) && line.length < 60)
    ) && (line === line.toUpperCase() || line.length < 60);
  }

  /**
   * Render professional PDF with exact formatting like original resume
   */
  private static renderProfessionalPDF(
    pdf: jsPDF,
    sections: ResumeSection[],
    jobTitle: string,
    companyName: string
  ): void {
    let yPosition = 30;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const footerSpace = 35;
    const maxContentHeight = pageHeight - footerSpace;
    
    // Set default font
    pdf.setFont('times', 'normal');
    
    try {
      sections.forEach((section) => {
        // Check if we need a new page
        if (yPosition > maxContentHeight - 60) {
          pdf.addPage();
          yPosition = 30;
        }
        
        if (section.type === 'header') {
          // Render header section exactly like original
          yPosition = this.renderHeaderSection(pdf, section, yPosition, pageWidth, margin);
        } else {
          // Render regular section exactly like original
          yPosition = this.renderRegularSection(pdf, section, yPosition, margin, contentWidth, maxContentHeight);
        }
      });
      
      // Add professional footer to all pages
      this.addProfessionalFooter(pdf, jobTitle, companyName);
    } catch (error) {
      console.error('❌ Error rendering PDF sections:', error);
      // Add fallback content
      pdf.setFontSize(12);
      pdf.setFont('times', 'normal');
      pdf.text('Error rendering resume content. Please try again.', margin, 50);
    }
  }

  /**
   * Render header section exactly like original (name and contact info)
   */
  private static renderHeaderSection(
    pdf: jsPDF,
    section: ResumeSection,
    yPosition: number,
    pageWidth: number,
    margin: number
  ): number {
    const content = section.content || [];
    
    if (content.length > 0) {
      try {
        // Name (first line) - Large, bold, centered like original
        pdf.setFontSize(18);
        pdf.setFont('times', 'bold');
        pdf.setTextColor(0, 0, 0);
        
        const nameText = content[0] || 'Professional Resume';
        const nameWidth = pdf.getTextWidth(nameText);
        const nameX = (pageWidth - nameWidth) / 2;
        pdf.text(nameText, nameX, yPosition);
        yPosition += 12;
        
        // Contact info - Smaller, centered like original
        pdf.setFontSize(10);
        pdf.setFont('times', 'normal');
        pdf.setTextColor(0, 0, 0);
        
        for (let i = 1; i < content.length; i++) {
          if (content[i] && content[i].trim()) {
            const contactText = content[i];
            const contactWidth = pdf.getTextWidth(contactText);
            const contactX = (pageWidth - contactWidth) / 2;
            pdf.text(contactText, contactX, yPosition);
            yPosition += 5;
          }
        }
      } catch (error) {
        console.error('❌ Error rendering header:', error);
        pdf.text('Professional Resume', margin, yPosition);
        yPosition += 12;
      }
    }
    
    return yPosition + 10;
  }

  /**
   * Render regular section exactly like original format
   */
  private static renderRegularSection(
    pdf: jsPDF,
    section: ResumeSection,
    yPosition: number,
    margin: number,
    contentWidth: number,
    maxContentHeight: number
  ): number {
    try {
      const pageWidth = pdf.internal.pageSize.getWidth();
      
      // Section header - exactly like original
      pdf.setFontSize(12);
      pdf.setFont('times', 'bold');
      pdf.setTextColor(0, 0, 0);
      pdf.text(section.title || 'Section', margin, yPosition);
      yPosition += 8;
      
      // Underline - exactly like original
      pdf.setLineWidth(0.8);
      pdf.setDrawColor(0, 0, 0);
      pdf.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 10;
      
      // Section content - exactly like original formatting
      pdf.setFontSize(10);
      pdf.setFont('times', 'normal');
      pdf.setTextColor(0, 0, 0);
      
      const content = section.content || [];
      
      for (const line of content) {
        if (!line || !line.trim()) {
          yPosition += 3;
          continue;
        }
        
        // Check if we need a new page
        if (yPosition > maxContentHeight - 25) {
          pdf.addPage();
          yPosition = 30;
        }
        
        try {
          // Handle bullet points exactly like original
          if (line.trim().startsWith('•') || line.trim().startsWith('-')) {
            const bulletText = line.trim().substring(1).trim();
            const wrappedText = pdf.splitTextToSize(`• ${bulletText}`, contentWidth - 5);
            
            wrappedText.forEach((wrappedLine: string, lineIndex: number) => {
              if (yPosition > maxContentHeight - 25) {
                pdf.addPage();
                yPosition = 30;
              }
              pdf.text(wrappedLine, margin + (lineIndex > 0 ? 3 : 0), yPosition);
              yPosition += 4.5;
            });
          } else {
            // Regular text - check if it should be bold (job titles, companies, dates)
            const shouldBeBold = this.shouldTextBeBold(line);
            const isRightAligned = this.shouldBeRightAligned(line);
            
            if (shouldBeBold) {
              pdf.setFont('times', 'bold');
            }
            
            if (isRightAligned) {
              // Right-align dates and locations
              const textWidth = pdf.getTextWidth(line);
              pdf.text(line, pageWidth - margin - textWidth, yPosition);
            } else {
              const wrappedText = pdf.splitTextToSize(line, contentWidth);
              
              wrappedText.forEach((wrappedLine: string) => {
                if (yPosition > maxContentHeight - 25) {
                  pdf.addPage();
                  yPosition = 30;
                }
                pdf.text(wrappedLine, margin, yPosition);
                yPosition += 4.5;
              });
            }
            
            if (shouldBeBold) {
              pdf.setFont('times', 'normal');
            }
            
            if (isRightAligned) {
              yPosition += 4.5;
            }
          }
        } catch (lineError) {
          console.error('❌ Error rendering line:', lineError);
          // Skip problematic line and continue
          yPosition += 4.5;
        }
      }
    } catch (error) {
      console.error('❌ Error rendering section:', error);
      // Add fallback text
      pdf.text('Section content unavailable', margin, yPosition);
      yPosition += 10;
    }
    
    return yPosition + 8;
  }

  /**
   * Check if text should be bold (job titles, companies, etc.)
   */
  private static shouldTextBeBold(line: string): boolean {
    if (!line || typeof line !== 'string') return false;
    
    // Check for university names, company names, job titles
    return (line.includes('University') || 
            line.includes('Group') || 
            line.includes('IBM') || 
            line.includes('Cognecto') ||
            line.includes('Engineer') ||
            line.includes('Developer') ||
            line.includes('Intern') ||
            line.includes('BTech') ||
            line.includes('Associate') ||
            line.includes('Manager') ||
            line.includes('Lead') ||
            line.includes('Senior')) && 
           !line.includes('•') && 
           line.length < 100;
  }

  /**
   * Check if text should be right-aligned (dates, locations)
   */
  private static shouldBeRightAligned(line: string): boolean {
    if (!line || typeof line !== 'string') return false;
    
    // Check for date patterns and locations
    return line.match(/\d{4}/) && 
           (line.includes('–') || line.includes('-') || line.includes('Present')) &&
           line.length < 50;
  }

  /**
   * Add professional footer to all pages
   */
  private static addProfessionalFooter(
    pdf: jsPDF,
    jobTitle: string,
    companyName: string
  ): void {
    try {
      const totalPages = pdf.getNumberOfPages();
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        
        // Footer styling
        pdf.setFontSize(8);
        pdf.setFont('times', 'normal');
        pdf.setTextColor(120, 120, 120);
        
        const footerText = `AI-Optimized Resume for ${jobTitle || 'Position'} at ${companyName || 'Company'} • Generated by FLASHFIRE • ${new Date().toLocaleDateString()}`;
        const footerY = pageHeight - 12;
        
        // Center the footer
        const footerWidth = pdf.getTextWidth(footerText);
        const footerX = (pageWidth - footerWidth) / 2;
        
        // Add subtle line above footer
        pdf.setLineWidth(0.2);
        pdf.setDrawColor(200, 200, 200);
        pdf.line(20, footerY - 6, pageWidth - 20, footerY - 6);
        
        pdf.text(footerText, footerX, footerY);
      }
    } catch (error) {
      console.error('❌ Error adding footer:', error);
    }
  }
}

/**
 * Main function to generate and download PDF
 */
export async function generatePDFResume(
  resumeContent: string,
  jobTitle: string,
  companyName: string
): Promise<Blob> {
  try {
    console.log('🚀 Starting PDF generation...');
    console.log('📄 Content length:', resumeContent?.length || 0);
    console.log('🎯 Job:', jobTitle, 'at', companyName);
    
    if (!resumeContent || resumeContent.trim().length === 0) {
      throw new Error('Resume content is empty or invalid');
    }
    
    const blob = await ProfessionalPDFGenerator.generatePDF(resumeContent, jobTitle, companyName);
    console.log('✅ PDF generated successfully');
    return blob;
  } catch (error) {
    console.error('❌ PDF Generation Failed:', error);
    throw new Error(`Failed to generate PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export function downloadPDF(blob: Blob, filename: string): void {
  try {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || 'resume.pdf';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    console.log('✅ PDF download initiated:', filename);
  } catch (error) {
    console.error('❌ PDF Download Failed:', error);
    throw new Error('Failed to download PDF');
  }
}