import jsPDF from 'jspdf';

/**
 * Clean PDF Generator - No additional text, exact format preservation
 */
export class CleanPDFGenerator {
  
  static async generateCleanPDF(htmlContent: string, filename: string): Promise<Blob> {
    return new Promise((resolve) => {
      const pdf = new jsPDF();
      
      // Extract text content from HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlContent;
      
      // Get clean text content
      const textContent = tempDiv.textContent || tempDiv.innerText || '';
      
      // Clean any remaining unwanted text
      const cleanContent = textContent
        .replace(/AI-Optimized Resume for.*?Generated by FLASHFIRE.*?\d{2}\/\d{2}\/\d{4}/gs, '')
        .replace(/Generated by FLASHFIRE.*$/gm, '')
        .trim();

      // Parse and render content
      this.renderCleanContent(pdf, cleanContent);
      
      const pdfBlob = pdf.output('blob');
      resolve(pdfBlob);
    });
  }

  private static renderCleanContent(pdf: jsPDF, content: string): void {
    const lines = content.split('\n').filter(line => line.trim());
    let yPosition = 30;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const margin = 20;
    const maxY = pdf.internal.pageSize.getHeight() - 30;

    pdf.setFont('times', 'normal');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;

      // Check for new page
      if (yPosition > maxY) {
        pdf.addPage();
        yPosition = 30;
      }

      // Determine formatting
      if (i < 3 && (line.includes('@') || line.includes('+') || !line.includes(' '))) {
        // Header content
        if (i === 0) {
          pdf.setFontSize(18);
          pdf.setFont('times', 'bold');
          const textWidth = pdf.getTextWidth(line);
          pdf.text(line, (pageWidth - textWidth) / 2, yPosition);
          yPosition += 12;
        } else {
          pdf.setFontSize(10);
          pdf.setFont('times', 'normal');
          const textWidth = pdf.getTextWidth(line);
          pdf.text(line, (pageWidth - textWidth) / 2, yPosition);
          yPosition += 6;
        }
      } else if (this.isSectionHeader(line)) {
        // Section headers
        pdf.setFontSize(12);
        pdf.setFont('times', 'bold');
        pdf.text(line.toUpperCase(), margin, yPosition);
        yPosition += 8;
        
        // Underline
        pdf.setLineWidth(0.5);
        pdf.line(margin, yPosition, pageWidth - margin, yPosition);
        yPosition += 10;
      } else {
        // Regular content
        pdf.setFontSize(10);
        pdf.setFont('times', 'normal');
        
        if (line.startsWith('•') || line.startsWith('-')) {
          // Bullet points
          const bulletText = line.substring(1).trim();
          const wrappedText = pdf.splitTextToSize(`• ${bulletText}`, pageWidth - margin * 2 - 5);
          
          wrappedText.forEach((wrappedLine: string) => {
            if (yPosition > maxY) {
              pdf.addPage();
              yPosition = 30;
            }
            pdf.text(wrappedLine, margin, yPosition);
            yPosition += 5;
          });
        } else {
          // Regular text
          const wrappedText = pdf.splitTextToSize(line, pageWidth - margin * 2);
          
          wrappedText.forEach((wrappedLine: string) => {
            if (yPosition > maxY) {
              pdf.addPage();
              yPosition = 30;
            }
            pdf.text(wrappedLine, margin, yPosition);
            yPosition += 5;
          });
        }
        yPosition += 3;
      }
    }
  }

  private static isSectionHeader(line: string): boolean {
    const headers = ['education', 'technical skills', 'experience', 'projects', 'certifications', 'additional technical skills'];
    return headers.some(header => line.toLowerCase().includes(header)) && line.length < 60;
  }
}

export async function generateCleanPDF(htmlContent: string, filename: string): Promise<Blob> {
  return CleanPDFGenerator.generateCleanPDF(htmlContent, filename);
}

export function downloadPDF(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}