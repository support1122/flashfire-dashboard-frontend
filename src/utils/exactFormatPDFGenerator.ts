import jsPDF from 'jspdf';

export interface ResumeSection {
  type: 'header' | 'section';
  title: string;
  content: string[];
}

/**
 * Exact Format PDF Generator - Maintains the EXACT format of the base resume
 */
export class ExactFormatPDFGenerator {
  
  static async generateExactFormatPDF(
    resumeContent: string,
    jobTitle: string,
    companyName: string
  ): Promise<Blob> {
    return new Promise((resolve, reject) => {
      try {
        console.log('🚀 Starting Exact Format PDF generation...');
        
        if (!resumeContent || typeof resumeContent !== 'string' || resumeContent.trim().length === 0) {
          throw new Error('Resume content is empty or invalid');
        }
        
        const pdf = new jsPDF();
        
        // Clean the content - remove any AI-generated text
        const cleanContent = this.cleanResumeContent(resumeContent);
        
        // Parse into exact sections matching the base resume format
        const sections = this.parseExactResumeStructure(cleanContent);
        
        console.log('📄 Generating PDF with exact formatting...');
        
        // Render with EXACT formatting like the base resume
        this.renderExactFormat(pdf, sections);
        
        // Return as blob
        const pdfBlob = pdf.output('blob');
        console.log('✅ Exact format PDF generated successfully');
        resolve(pdfBlob);
      } catch (error) {
        console.error('❌ PDF Generation Error:', error);
        reject(new Error(`PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`));
      }
    });
  }

  /**
   * Clean resume content of any unwanted text
   */
  private static cleanResumeContent(content: string): string {
    if (!content || typeof content !== 'string') {
      console.warn('⚠️ Invalid content provided to PDF generator');
      return 'Resume content not available';
    }

    return content
      // Remove any AI-generated footer text
      .replace(/AI-Optimized Resume for.*?Generated by FLASHFIRE.*?\d{2}\/\d{2}\/\d{4}/gs, '')
      .replace(/•\s*Generated by FLASHFIRE.*$/gm, '')
      .replace(/Generated by FLASHFIRE.*$/gm, '')
      .replace(/\s*•\s*AI-Optimized.*$/gm, '')
      // Clean up extra whitespace
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      .trim();
  }

  /**
   * Parse resume into exact structure matching base resume
   */
  private static parseExactResumeStructure(content: string): ResumeSection[] {
    if (!content) {
      return [{
        type: 'header',
        title: 'Header',
        content: ['Resume content not available']
      }];
    }

    const lines = content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const sections: ResumeSection[] = [];
    let currentSection: ResumeSection | null = null;
    
    for (const line of lines) {
      if (this.isSectionHeader(line)) {
        // Save previous section
        if (currentSection && currentSection.content.length > 0) {
          sections.push(currentSection);
        }
        
        // Start new section
        currentSection = {
          type: 'section',
          title: line,
          content: []
        };
      } else if (currentSection) {
        // Add to current section
        currentSection.content.push(line);
      } else {
        // This is header content (name, contact info)
        if (sections.length === 0 || sections[0].type !== 'header') {
          sections.unshift({
            type: 'header',
            title: 'Header',
            content: [line]
          });
        } else {
          sections[0].content.push(line);
        }
      }
    }
    
    // Add final section
    if (currentSection && currentSection.content.length > 0) {
      sections.push(currentSection);
    }

    // Ensure we have at least a header section
    if (sections.length === 0) {
      sections.push({
        type: 'header',
        title: 'Header',
        content: ['Professional Resume']
      });
    }
    
    return sections;
  }

  /**
   * Check if line is a section header
   */
  private static isSectionHeader(line: string): boolean {
    if (!line || typeof line !== 'string') return false;

    const sectionKeywords = [
      'summary', 'work experience', 'skills', 'education', 'leadership & volunteering',
      'certifications', 'technical skills', 'experience', 'projects', 
      'additional technologies', 'additional technical skills'
    ];
    
    const lowerLine = line.toLowerCase().trim();
    
    return sectionKeywords.some(keyword => 
      lowerLine === keyword || 
      (lowerLine.includes(keyword) && line.length < 60)
    ) && (line === line.toUpperCase() || line.length < 60);
  }

  /**
   * Render with EXACT formatting matching the base resume
   */
  private static renderExactFormat(pdf: jsPDF, sections: ResumeSection[]): void {
    let yPosition = 25;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const maxContentHeight = pageHeight - 40;
    
    // Set default font to Times New Roman (like base resume)
    pdf.setFont('times', 'normal');
    
    try {
      sections.forEach((section) => {
        // Check if we need a new page
        if (yPosition > maxContentHeight - 60) {
          pdf.addPage();
          yPosition = 25;
        }
        
        if (section.type === 'header') {
          // Render header section EXACTLY like base resume
          yPosition = this.renderExactHeader(pdf, section, yPosition, pageWidth, margin);
        } else {
          // Render regular section EXACTLY like base resume
          yPosition = this.renderExactSection(pdf, section, yPosition, margin, contentWidth, maxContentHeight, pageWidth);
        }
      });
      
    } catch (error) {
      console.error('❌ Error rendering PDF sections:', error);
      // Add fallback content
      pdf.setFontSize(12);
      pdf.setFont('times', 'normal');
      pdf.text('Error rendering resume content. Please try again.', margin, 50);
    }
  }

  /**
   * Render header section EXACTLY like base resume
   */
  private static renderExactHeader(
    pdf: jsPDF,
    section: ResumeSection,
    yPosition: number,
    pageWidth: number,
    margin: number
  ): number {
    const content = section.content || [];
    
    if (content.length > 0) {
      try {
        // Name (first line) - Large, bold, centered EXACTLY like base
        pdf.setFontSize(20);
        pdf.setFont('times', 'bold');
        pdf.setTextColor(0, 0, 0);
        
        const nameText = content[0] || 'Professional Resume';
        const nameWidth = pdf.getTextWidth(nameText);
        const nameX = (pageWidth - nameWidth) / 2;
        pdf.text(nameText, nameX, yPosition);
        yPosition += 15;
        
        // Job title/subtitle - Medium, centered
        if (content.length > 1 && content[1] && !content[1].includes('@') && !content[1].includes('+')) {
          pdf.setFontSize(12);
          pdf.setFont('times', 'normal');
          const subtitleText = content[1];
          const subtitleWidth = pdf.getTextWidth(subtitleText);
          const subtitleX = (pageWidth - subtitleWidth) / 2;
          pdf.text(subtitleText, subtitleX, yPosition);
          yPosition += 10;
        }
        
        // Contact info - Smaller, centered EXACTLY like base
        pdf.setFontSize(10);
        pdf.setFont('times', 'normal');
        pdf.setTextColor(0, 0, 0);
        
        for (let i = 1; i < content.length; i++) {
          if (content[i] && content[i].trim()) {
            const contactText = content[i];
            // Skip if already processed as subtitle
            if (i === 1 && !contactText.includes('@') && !contactText.includes('+') && !contactText.includes('|')) {
              continue;
            }
            const contactWidth = pdf.getTextWidth(contactText);
            const contactX = (pageWidth - contactWidth) / 2;
            pdf.text(contactText, contactX, yPosition);
            yPosition += 5;
          }
        }
      } catch (error) {
        console.error('❌ Error rendering header:', error);
        pdf.text('Professional Resume', margin, yPosition);
        yPosition += 15;
      }
    }
    
    return yPosition + 15;
  }

  /**
   * Render regular section EXACTLY like base resume format
   */
  private static renderExactSection(
    pdf: jsPDF,
    section: ResumeSection,
    yPosition: number,
    margin: number,
    contentWidth: number,
    maxContentHeight: number,
    pageWidth: number
  ): number {
    try {
      // Section header - EXACTLY like base resume
      pdf.setFontSize(12);
      pdf.setFont('times', 'bold');
      pdf.setTextColor(0, 0, 0);
      pdf.text(section.title.toUpperCase(), margin, yPosition);
      yPosition += 8;
      
      // Underline - EXACTLY like base resume
      pdf.setLineWidth(1);
      pdf.setDrawColor(0, 0, 0);
      pdf.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 12;
      
      // Section content - EXACTLY like base resume formatting
      pdf.setFontSize(10);
      pdf.setFont('times', 'normal');
      pdf.setTextColor(0, 0, 0);
      
      const content = section.content || [];
      
      for (const line of content) {
        if (!line || !line.trim()) {
          yPosition += 4;
          continue;
        }
        
        // Check if we need a new page
        if (yPosition > maxContentHeight - 25) {
          pdf.addPage();
          yPosition = 25;
        }
        
        try {
          // Handle different types of content EXACTLY like base resume
          if (line.trim().startsWith('•') || line.trim().startsWith('-')) {
            // Bullet points - EXACTLY like base resume
            const bulletText = line.trim().substring(1).trim();
            const wrappedText = pdf.splitTextToSize(`• ${bulletText}`, contentWidth - 10);
            
            wrappedText.forEach((wrappedLine: string, lineIndex: number) => {
              if (yPosition > maxContentHeight - 25) {
                pdf.addPage();
                yPosition = 25;
              }
              pdf.text(wrappedLine, margin + (lineIndex > 0 ? 5 : 0), yPosition);
              yPosition += 5;
            });
          } else {
            // Check if this should be bold (job titles, companies, dates)
            const shouldBeBold = this.shouldTextBeBold(line);
            const isRightAligned = this.shouldBeRightAligned(line);
            
            if (shouldBeBold) {
              pdf.setFont('times', 'bold');
              pdf.setFontSize(11);
            }
            
            if (isRightAligned) {
              // Right-align dates and locations EXACTLY like base resume
              const textWidth = pdf.getTextWidth(line);
              pdf.text(line, pageWidth - margin - textWidth, yPosition);
              yPosition += 5;
            } else {
              const wrappedText = pdf.splitTextToSize(line, contentWidth);
              
              wrappedText.forEach((wrappedLine: string) => {
                if (yPosition > maxContentHeight - 25) {
                  pdf.addPage();
                  yPosition = 25;
                }
                pdf.text(wrappedLine, margin, yPosition);
                yPosition += 5;
              });
            }
            
            if (shouldBeBold) {
              pdf.setFont('times', 'normal');
              pdf.setFontSize(10);
            }
          }
        } catch (lineError) {
          console.error('❌ Error rendering line:', lineError);
          // Skip problematic line and continue
          yPosition += 5;
        }
      }
    } catch (error) {
      console.error('❌ Error rendering section:', error);
      // Add fallback text
      pdf.text('Section content unavailable', margin, yPosition);
      yPosition += 10;
    }
    
    return yPosition + 10;
  }

  /**
   * Check if text should be bold (job titles, companies, etc.) - EXACTLY like base resume
   */
  private static shouldTextBeBold(line: string): boolean {
    if (!line || typeof line !== 'string') return false;
    
    // Check for patterns that are bold in the base resume
    return (
      // Job titles and companies
      (line.includes('Manager') || line.includes('Intern') || line.includes('Coordinator') || 
       line.includes('Advisor') || line.includes('Senator') || line.includes('Associate') ||
       line.includes('Product') || line.includes('Program') || line.includes('Strategic')) &&
      !line.includes('•') && 
      line.length < 100 &&
      !line.includes(':')
    ) || (
      // University names and degrees
      line.includes('University') || line.includes('Bachelor') || line.includes('Master') ||
      line.includes('Engineering') || line.includes('Science')
    );
  }

  /**
   * Check if text should be right-aligned (dates, locations) - EXACTLY like base resume
   */
  private static shouldBeRightAligned(line: string): boolean {
    if (!line || typeof line !== 'string') return false;
    
    // Check for date patterns and locations that are right-aligned in base resume
    return (
      line.match(/\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}/) ||
      line.match(/\d{4}\s*—\s*\d{4}/) ||
      line.match(/\d{4}\s*—\s*(Present|Current)/) ||
      (line.includes('2024') && line.includes('—')) ||
      (line.includes('2023') && line.includes('—')) ||
      (line.includes('2022') && line.includes('—'))
    ) && line.length < 50;
  }
}

/**
 * Main function to generate exact format PDF
 */
export async function generateExactFormatPDF(
  resumeContent: string,
  jobTitle: string,
  companyName: string
): Promise<Blob> {
  try {
    console.log('🚀 Starting exact format PDF generation...');
    console.log('📄 Content length:', resumeContent?.length || 0);
    console.log('🎯 Job:', jobTitle, 'at', companyName);
    
    if (!resumeContent || resumeContent.trim().length === 0) {
      throw new Error('Resume content is empty or invalid');
    }
    
    const blob = await ExactFormatPDFGenerator.generateExactFormatPDF(resumeContent, jobTitle, companyName);
    console.log('✅ Exact format PDF generated successfully');
    return blob;
  } catch (error) {
    console.error('❌ Exact Format PDF Generation Failed:', error);
    throw new Error(`Failed to generate PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export function downloadPDF(blob: Blob, filename: string): void {
  try {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || 'resume.pdf';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    console.log('✅ PDF download initiated:', filename);
  } catch (error) {
    console.error('❌ PDF Download Failed:', error);
    throw new Error('Failed to download PDF');
  }
}