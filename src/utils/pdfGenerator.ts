import jsPDF from 'jspdf';

export interface ResumeSection {
  title: string;
  content: string;
  type: 'header' | 'summary' | 'experience' | 'education' | 'skills' | 'section';
}

export function parseResumeContent(content: string): ResumeSection[] {
  // First, completely clean the content of any existing footer text
  let cleanContent = content
    .replace(/AI-Optimized Resume for.*?Generated by FLASHFIRE.*?\d{2}\/\d{2}\/\d{4}/gs, '')
    .replace(/•\s*Generated by FLASHFIRE.*$/gm, '')
    .replace(/Generated by FLASHFIRE.*$/gm, '')
    .trim();

  const lines = cleanContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);
  const sections: ResumeSection[] = [];
  let currentSection: ResumeSection | null = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if this line is a section header
    if (isSectionHeader(line)) {
      // Save previous section
      if (currentSection && currentSection.content.trim()) {
        sections.push(currentSection);
      }
      
      // Start new section
      const sectionType = getSectionType(line);
      currentSection = { type: sectionType, title: line, content: '' };
    } else if (currentSection) {
      // Add content to current section
      currentSection.content += (currentSection.content ? '\n' : '') + line;
    } else {
      // This is likely header content (name, contact info)
      if (sections.length === 0 || sections[0].type !== 'header') {
        sections.unshift({
          type: 'header',
          title: 'Header',
          content: line
        });
      } else {
        sections[0].content += '\n' + line;
      }
    }
  }
  
  // Add the last section
  if (currentSection && currentSection.content.trim()) {
    sections.push(currentSection);
  }
  
  return sections;
}

function isSectionHeader(line: string): boolean {
  const sectionKeywords = [
    'summary', 'professional summary', 'objective', 'profile',
    'experience', 'work experience', 'professional experience', 'employment',
    'education', 'academic background', 'qualifications',
    'skills', 'technical skills', 'core competencies', 'expertise',
    'projects', 'certifications', 'achievements', 'awards', 'leadership',
    'additional relevant skills', 'additional technologies'
  ];
  
  const lowerLine = line.toLowerCase().trim();
  
  // Check for exact matches or if it's an all-caps section header
  return sectionKeywords.some(keyword => 
    lowerLine === keyword || 
    (lowerLine.includes(keyword) && line.length < 50)
  ) && (line === line.toUpperCase() || line.length < 50);
}

function getSectionType(line: string): ResumeSection['type'] {
  const lowerLine = line.toLowerCase();
  
  if (lowerLine.includes('summary') || lowerLine.includes('objective') || lowerLine.includes('profile')) {
    return 'summary';
  } else if (lowerLine.includes('experience') || lowerLine.includes('employment')) {
    return 'experience';
  } else if (lowerLine.includes('education') || lowerLine.includes('academic')) {
    return 'education';
  } else if (lowerLine.includes('skills') || lowerLine.includes('competencies') || lowerLine.includes('expertise')) {
    return 'skills';
  }
  
  return 'section';
}

export function generatePDFResume(
  resumeContent: string,
  jobTitle: string,
  companyName: string
): Promise<Blob> {
  return new Promise((resolve) => {
    const pdf = new jsPDF();
    
    // Parse the content into clean sections
    const sections = parseResumeContent(resumeContent);
    
    let yPosition = 25;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const footerHeight = 25;
    const maxContentHeight = pageHeight - footerHeight - 15;
    
    // Set up fonts
    pdf.setFont('helvetica');
    
    console.log('Processing sections:', sections.map(s => ({ type: s.type, title: s.title })));
    
    sections.forEach((section, index) => {
      // Check if we need a new page
      if (yPosition > maxContentHeight - 50) {
        pdf.addPage();
        yPosition = 25;
      }
      
      switch (section.type) {
        case 'header':
          // Process header content
          const headerLines = section.content.split('\n').filter(line => line.trim());
          
          if (headerLines.length > 0) {
            // Name (first line) - Large, bold, centered
            pdf.setFontSize(22);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(0, 0, 0);
            
            const nameText = headerLines[0];
            const nameWidth = pdf.getTextWidth(nameText);
            const nameX = (pageWidth - nameWidth) / 2;
            pdf.text(nameText, nameX, yPosition);
            yPosition += 15;
            
            // Contact info - Smaller, centered
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(80, 80, 80);
            
            for (let i = 1; i < headerLines.length; i++) {
              if (headerLines[i].trim()) {
                const contactText = headerLines[i];
                const contactWidth = pdf.getTextWidth(contactText);
                const contactX = (pageWidth - contactWidth) / 2;
                pdf.text(contactText, contactX, yPosition);
                yPosition += 6;
              }
            }
          }
          yPosition += 12;
          break;
          
        default:
          // All other sections
          if (section.title && section.content) {
            // Section header
            pdf.setFontSize(14);
            pdf.setFont('helvetica', 'bold');
            pdf.setTextColor(0, 0, 0);
            pdf.text(section.title.toUpperCase(), margin, yPosition);
            yPosition += 8;
            
            // Underline
            pdf.setLineWidth(1);
            pdf.setDrawColor(0, 0, 0);
            pdf.line(margin, yPosition, pageWidth - margin, yPosition);
            yPosition += 12;
            
            // Section content
            pdf.setFontSize(11);
            pdf.setFont('helvetica', 'normal');
            pdf.setTextColor(0, 0, 0);
            
            const contentLines = section.content.split('\n');
            
            contentLines.forEach((line) => {
              if (!line.trim()) {
                yPosition += 4;
                return;
              }
              
              // Check if we need a new page
              if (yPosition > maxContentHeight - 25) {
                pdf.addPage();
                yPosition = 25;
              }
              
              // Handle bullet points
              if (line.trim().startsWith('•') || line.trim().startsWith('-')) {
                const bulletText = line.trim().substring(1).trim();
                const wrappedText = pdf.splitTextToSize(`• ${bulletText}`, contentWidth - 10);
                
                wrappedText.forEach((wrappedLine: string, lineIndex: number) => {
                  if (yPosition > maxContentHeight - 25) {
                    pdf.addPage();
                    yPosition = 25;
                  }
                  pdf.text(wrappedLine, margin + (lineIndex > 0 ? 5 : 0), yPosition);
                  yPosition += 5.5;
                });
              } else {
                // Regular text
                const wrappedText = pdf.splitTextToSize(line, contentWidth);
                
                // Check if this should be bold (job titles, company names)
                const shouldBeBold = line.match(/^[A-Z]/) && 
                                   !line.includes('•') && 
                                   line.length < 100 && 
                                   (line.includes('Manager') || line.includes('Engineer') || 
                                    line.includes('Developer') || line.includes('Analyst') || 
                                    line.includes('Product') || line.includes('Senior') || 
                                    line.includes('Lead') || line.includes('Coordinator'));
                
                if (shouldBeBold) {
                  pdf.setFont('helvetica', 'bold');
                  pdf.setFontSize(12);
                }
                
                wrappedText.forEach((wrappedLine: string) => {
                  if (yPosition > maxContentHeight - 25) {
                    pdf.addPage();
                    yPosition = 25;
                  }
                  pdf.text(wrappedLine, margin, yPosition);
                  yPosition += 5.5;
                });
                
                if (shouldBeBold) {
                  pdf.setFont('helvetica', 'normal');
                  pdf.setFontSize(11);
                }
              }
            });
            
            yPosition += 10;
          }
          break;
      }
    });
    
    // Add footer to all pages - SEPARATE from content
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      // Footer styling
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(120, 120, 120);
      
      const footerText = `AI-Optimized Resume for ${jobTitle} at ${companyName} • Generated by FLASHFIRE • ${new Date().toLocaleDateString()}`;
      const footerY = pageHeight - 12;
      
      // Center the footer
      const footerWidth = pdf.getTextWidth(footerText);
      const footerX = (pageWidth - footerWidth) / 2;
      
      // Add a subtle line above footer
      pdf.setLineWidth(0.3);
      pdf.setDrawColor(200, 200, 200);
      pdf.line(margin, footerY - 5, pageWidth - margin, footerY - 5);
      
      pdf.text(footerText, footerX, footerY);
    }
    
    // Generate and return the blob
    const pdfBlob = pdf.output('blob');
    resolve(pdfBlob);
  });
}

export function downloadPDF(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}